<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é­”æ³•ä½¿ã„ã®é™£å–ã‚Š</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            display: flex;
            gap: 30px;
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.3);
        }

        .board-container {
            position: relative;
        }

        svg {
            background: #f5f5f5;
            border-radius: 10px;
        }

        .hex {
            stroke: #333;
            stroke-width: 2;
            cursor: pointer;
            transition: all 0.2s;
        }

        .hex.empty {
            fill: #ffffff;
        }

        .hex.selectable {
            fill: #ffffcc;
            cursor: pointer;
        }

        .hex.selected {
            fill: #ffeb3b;
            stroke-width: 4;
        }

        .territory-1 {
            fill: #e3f2fd;
        }

        .territory-2 {
            fill: #fce4ec;
        }

        .territory-double-1 {
            fill: #1976d2;
        }

        .territory-double-2 {
            fill: #c2185b;
        }

        .wizard {
            cursor: pointer;
            transition: transform 0.2s;
        }

        .wizard:hover {
            transform: scale(1.1);
        }

        .wizard-1 {
            fill: #2196f3;
        }

        .wizard-2 {
            fill: #e91e63;
        }

        .info-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 250px;
        }

        .player-info {
            padding: 20px;
            border-radius: 10px;
            transition: all 0.3s;
        }

        .player-info.active {
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            transform: scale(1.05);
        }

        .player-1 {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border: 3px solid #2196f3;
        }

        .player-2 {
            background: linear-gradient(135deg, #fce4ec 0%, #f8bbd0 100%);
            border: 3px solid #e91e63;
        }

        .player-info h2 {
            margin-bottom: 10px;
            font-size: 24px;
        }

        .player-info p {
            margin: 5px 0;
            font-size: 16px;
        }

        .rules {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.6;
            max-height: 400px;
            overflow-y: auto;
        }

        .rules h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .rules ul {
            margin-left: 20px;
        }

        .rules li {
            margin: 5px 0;
        }

        .message {
            background: #fff3cd;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ffc107;
            text-align: center;
            font-weight: bold;
        }

        .winner {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
            font-size: 18px;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="board-container">
            <svg id="board" width="600" height="600"></svg>
        </div>
        <div class="info-panel">
            <div id="player1-info" class="player-info player-1 active">
                <h2>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1 (é’)</h2>
                <p>æ®‹ã‚Šé™£åœ°: <span id="p1-tokens">20</span></p>
                <p>ç›¤é¢é™£åœ°: <span id="p1-board">0</span></p>
            </div>
            <div id="player2-info" class="player-info player-2">
                <h2>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2 (èµ¤)</h2>
                <p>æ®‹ã‚Šé™£åœ°: <span id="p2-tokens">20</span></p>
                <p>ç›¤é¢é™£åœ°: <span id="p2-board">0</span></p>
            </div>
            <div id="message" class="message">
                ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã®ã‚¿ãƒ¼ãƒ³<br>é­”æ³•ä½¿ã„ã‚’é¸æŠã—ã¦ãã ã•ã„
            </div>
            <button onclick="game.newGame()">æ–°ã—ã„ã‚²ãƒ¼ãƒ </button>
            <div class="rules">
                <h3>ãƒ«ãƒ¼ãƒ«</h3>
                <ul>
                    <li>é­”æ³•ä½¿ã„ã‚’é¸æŠã—ã¦ç§»å‹•å…ˆã‚’ã‚¯ãƒªãƒƒã‚¯</li>
                    <li>ç§»å‹•å¾Œã€é­”æ³•ä½¿ã„åŒå£«ã‚’çµã¶ç›´ç·šä¸Šã«é™£åœ°ã‚’é…ç½®</li>
                    <li>é­”æ³•ä½¿ã„3å€‹ãŒæ­£ä¸‰è§’å½¢ã‚’ä½œã‚‹ã¨ä¸­å¤®ã«å®ˆå‚™é™£åœ°(æ¿ƒè‰²)ã‚’é…ç½®</li>
                    <li>å®ˆå‚™é™£åœ°ã¯å¥ªã‚ã‚Œãªã„</li>
                    <li>20å€‹ã®é™£åœ°ã‚’é…ç½®ã™ã‚‹ã‹ã€é™£åœ°æ•°ãŒå¤šã„æ–¹ãŒå‹åˆ©</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // ã‚­ãƒ¥ãƒ¼ãƒ–åº§æ¨™ç³»ã§ã®å…­è§’å½¢ã‚°ãƒªãƒƒãƒ‰
        class HexGrid {
            constructor(radius) {
                this.radius = radius;
                this.hexSize = 30;
                this.cells = new Map();
                this.initGrid();
            }

            initGrid() {
                // æ­£å…­è§’å½¢ã®ã‚°ãƒªãƒƒãƒ‰ã‚’ç”Ÿæˆï¼ˆä¸­å¿ƒã‹ã‚‰åŠå¾„radiusã¾ã§ï¼‰
                for (let q = -this.radius; q <= this.radius; q++) {
                    for (let r = -this.radius; r <= this.radius; r++) {
                        const s = -q - r;
                        if (Math.abs(s) <= this.radius) {
                            const key = this.getKey(q, r, s);
                            this.cells.set(key, {
                                q, r, s,
                                territory: null,  // null, 1, 2
                                territoryCount: 1, // 1 or 2 (for double territory)
                                wizard: null      // null, 1, 2
                            });
                        }
                    }
                }
            }

            getKey(q, r, s) {
                return `${q},${r},${s}`;
            }

            getCell(q, r, s) {
                return this.cells.get(this.getKey(q, r, s));
            }

            // ã‚­ãƒ¥ãƒ¼ãƒ–åº§æ¨™ã‹ã‚‰ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã¸ã®å¤‰æ›
            hexToPixel(q, r) {
                const x = this.hexSize * (3/2 * q);
                const y = this.hexSize * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
                return { x, y };
            }

            // å…­è§’å½¢ã®é ‚ç‚¹ã‚’å–å¾—
            getHexPoints(x, y) {
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 180 * (60 * i + 30);
                    const px = x + this.hexSize * Math.cos(angle);
                    const py = y + this.hexSize * Math.sin(angle);
                    points.push(`${px},${py}`);
                }
                return points.join(' ');
            }
        }

        class WizardTerritoryGame {
            constructor() {
                this.grid = new HexGrid(3);
                this.currentPlayer = 1;
                this.selectedWizard = null;
                this.tokensRemaining = { 1: 20, 2: 20 };
                this.consecutivePasses = 0;
                this.gameOver = false;
                this.initBoard();
                this.newGame();
            }

            initBoard() {
                const svg = document.getElementById('board');
                const centerX = 300;
                const centerY = 300;

                // å…­è§’å½¢ã‚’æç”»
                this.grid.cells.forEach((cell, key) => {
                    const pos = this.grid.hexToPixel(cell.q, cell.r);
                    const x = centerX + pos.x;
                    const y = centerY + pos.y;

                    const hex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    hex.setAttribute('points', this.grid.getHexPoints(x, y));
                    hex.setAttribute('class', 'hex empty');
                    hex.setAttribute('data-key', key);
                    hex.addEventListener('click', (e) => this.onHexClick(key));

                    cell.element = hex;
                    cell.pixelX = x;
                    cell.pixelY = y;
                    svg.appendChild(hex);
                });
            }

            newGame() {
                this.currentPlayer = 1;
                this.selectedWizard = null;
                this.tokensRemaining = { 1: 20, 2: 20 };
                this.consecutivePasses = 0;
                this.gameOver = false;

                // ã‚°ãƒªãƒƒãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.grid.cells.forEach(cell => {
                    cell.territory = null;
                    cell.territoryCount = 1;
                    cell.wizard = null;
                });

                // åˆæœŸé…ç½®: å¯¾è§’ã®ç«¯ã«3å€‹ãšã¤
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1: å·¦ä¸Šç«¯
                const p1Positions = [
                    {q: -3, r: 0, s: 3},
                    {q: -3, r: 1, s: 2},
                    {q: -2, r: -1, s: 3}
                ];

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2: å³ä¸‹ç«¯
                const p2Positions = [
                    {q: 3, r: 0, s: -3},
                    {q: 3, r: -1, s: -2},
                    {q: 2, r: 1, s: -3}
                ];

                p1Positions.forEach(pos => {
                    const cell = this.grid.getCell(pos.q, pos.r, pos.s);
                    if (cell) cell.wizard = 1;
                });

                p2Positions.forEach(pos => {
                    const cell = this.grid.getCell(pos.q, pos.r, pos.s);
                    if (cell) cell.wizard = 2;
                });

                this.render();
                this.updateInfo();
            }

            onHexClick(key) {
                if (this.gameOver) return;

                const cell = this.grid.cells.get(key);

                // é­”æ³•ä½¿ã„ã®é¸æŠ
                if (cell.wizard === this.currentPlayer) {
                    this.selectedWizard = key;
                    this.render();
                    this.updateMessage(`é­”æ³•ä½¿ã„ã‚’é¸æŠã—ã¾ã—ãŸã€‚ç§»å‹•å…ˆã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„`);
                    return;
                }

                // ç§»å‹•
                if (this.selectedWizard) {
                    this.tryMove(this.selectedWizard, key);
                }
            }

            tryMove(fromKey, toKey) {
                const fromCell = this.grid.cells.get(fromKey);
                const toCell = this.grid.cells.get(toKey);

                // ç§»å‹•å…ˆã®æ¤œè¨¼
                if (toCell.wizard) {
                    this.updateMessage('ãã“ã«ã¯æ—¢ã«é­”æ³•ä½¿ã„ãŒã„ã¾ã™');
                    return;
                }

                if (toCell.territory === (3 - this.currentPlayer)) {
                    this.updateMessage('ç›¸æ‰‹ã®é™£åœ°ã«ã¯ç§»å‹•ã§ãã¾ã›ã‚“');
                    return;
                }

                // ç§»å‹•ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã¦é™£åœ°ãŒå¢—ãˆã‚‹ã‹ç¢ºèª
                const originalWizard = fromCell.wizard;
                fromCell.wizard = null;
                toCell.wizard = this.currentPlayer;

                const newTerritories = this.calculateNewTerritories();

                if (newTerritories.length === 0) {
                    // é™£åœ°ãŒå¢—ãˆãªã„ç§»å‹•ã¯ä¸å¯
                    fromCell.wizard = originalWizard;
                    toCell.wizard = null;
                    this.updateMessage('é™£åœ°ã‚’å¢—ã‚„ã›ãªã„ç§»å‹•ã¯ã§ãã¾ã›ã‚“');
                    return;
                }

                // ç§»å‹•ã‚’ç¢ºå®š
                this.placeTerritories(newTerritories);
                this.checkAndPlaceTriangleTerritories();
                this.selectedWizard = null;
                this.consecutivePasses = 0;

                // å‹åˆ©åˆ¤å®š
                if (this.checkWin()) {
                    return;
                }

                // ã‚¿ãƒ¼ãƒ³äº¤ä»£
                this.currentPlayer = 3 - this.currentPlayer;

                // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç§»å‹•ã§ãã‚‹ã‹ç¢ºèª
                if (!this.hasValidMoves()) {
                    this.consecutivePasses++;
                    if (this.consecutivePasses >= 2) {
                        this.endGame();
                    } else {
                        this.updateMessage(`ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.currentPlayer}ã¯ç§»å‹•ã§ãã¾ã›ã‚“ã€‚ãƒ‘ã‚¹ã—ã¾ã™`);
                        setTimeout(() => {
                            this.currentPlayer = 3 - this.currentPlayer;
                            this.render();
                            this.updateInfo();
                        }, 2000);
                    }
                } else {
                    this.consecutivePasses = 0;
                    this.render();
                    this.updateInfo();
                }
            }

            calculateNewTerritories() {
                const wizards = [];
                this.grid.cells.forEach(cell => {
                    if (cell.wizard === this.currentPlayer) {
                        wizards.push(cell);
                    }
                });

                const newTerritories = new Set();

                // å„é­”æ³•ä½¿ã„ã®ãƒšã‚¢ã«ã¤ã„ã¦ç›´ç·šä¸Šã®é™£åœ°ã‚’è¨ˆç®—
                for (let i = 0; i < wizards.length; i++) {
                    for (let j = i + 1; j < wizards.length; j++) {
                        const w1 = wizards[i];
                        const w2 = wizards[j];
                        const line = this.getLineBetween(w1, w2);

                        line.forEach(cell => {
                            // æ–°ã—ã„é™£åœ°ã¾ãŸã¯ç›¸æ‰‹ã‹ã‚‰å¥ªãˆã‚‹é™£åœ°
                            if (!cell.territory ||
                                (cell.territory !== this.currentPlayer && cell.territoryCount === 1)) {
                                newTerritories.add(cell);
                            }
                        });
                    }
                }

                // é­”æ³•ä½¿ã„ãŒã„ã‚‹ãƒã‚¹è‡ªä½“ã‚‚é™£åœ°ã«å«ã‚ã‚‹
                wizards.forEach(w => {
                    if (!w.territory || w.territory !== this.currentPlayer) {
                        newTerritories.add(w);
                    }
                });

                return Array.from(newTerritories);
            }

            getLineBetween(cell1, cell2) {
                const dq = cell2.q - cell1.q;
                const dr = cell2.r - cell1.r;
                const ds = cell2.s - cell1.s;

                // 3æ–¹å‘ã®ã„ãšã‚Œã‹ã®ç›´ç·šä¸Šã«ã‚ã‚‹ã‹ç¢ºèª
                const line = [];

                if (dq === 0) {
                    // qè»¸æ–¹å‘ã®ç›´ç·š
                    const minR = Math.min(cell1.r, cell2.r);
                    const maxR = Math.max(cell1.r, cell2.r);
                    for (let r = minR; r <= maxR; r++) {
                        const s = -cell1.q - r;
                        const cell = this.grid.getCell(cell1.q, r, s);
                        if (cell) line.push(cell);
                    }
                } else if (dr === 0) {
                    // rè»¸æ–¹å‘ã®ç›´ç·š
                    const minQ = Math.min(cell1.q, cell2.q);
                    const maxQ = Math.max(cell1.q, cell2.q);
                    for (let q = minQ; q <= maxQ; q++) {
                        const s = -q - cell1.r;
                        const cell = this.grid.getCell(q, cell1.r, s);
                        if (cell) line.push(cell);
                    }
                } else if (ds === 0) {
                    // sè»¸æ–¹å‘ã®ç›´ç·š
                    const minQ = Math.min(cell1.q, cell2.q);
                    const maxQ = Math.max(cell1.q, cell2.q);
                    for (let q = minQ; q <= maxQ; q++) {
                        const r = -q - cell1.s;
                        const cell = this.grid.getCell(q, r, cell1.s);
                        if (cell) line.push(cell);
                    }
                }

                return line;
            }

            placeTerritories(territories) {
                territories.forEach(cell => {
                    if (cell.territoryCount === 2) {
                        // å®ˆå‚™é™£åœ°ã¯å¥ªãˆãªã„
                        return;
                    }

                    if (cell.territory !== this.currentPlayer) {
                        if (this.tokensRemaining[this.currentPlayer] > 0) {
                            cell.territory = this.currentPlayer;
                            cell.territoryCount = 1;
                            this.tokensRemaining[this.currentPlayer]--;
                        }
                    }
                });
            }

            checkAndPlaceTriangleTerritories() {
                const wizards = [];
                this.grid.cells.forEach(cell => {
                    if (cell.wizard === this.currentPlayer) {
                        wizards.push(cell);
                    }
                });

                if (wizards.length !== 3) return;

                // 3ã¤ã®é­”æ³•ä½¿ã„ãŒæ­£ä¸‰è§’å½¢ï¼ˆå„è¾º2ãƒã‚¹ï¼‰ã‚’å½¢æˆã—ã¦ã„ã‚‹ã‹ç¢ºèª
                const distances = [];
                for (let i = 0; i < 3; i++) {
                    for (let j = i + 1; j < 3; j++) {
                        const dist = this.hexDistance(wizards[i], wizards[j]);
                        distances.push(dist);
                    }
                }

                // å„è¾ºãŒ2ãƒã‚¹ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
                if (distances.every(d => d === 2)) {
                    // ä¸­å¤®ã®ãƒã‚¹ã‚’è¨ˆç®—
                    const centerQ = Math.round((wizards[0].q + wizards[1].q + wizards[2].q) / 3);
                    const centerR = Math.round((wizards[0].r + wizards[1].r + wizards[2].r) / 3);
                    const centerS = Math.round((wizards[0].s + wizards[1].s + wizards[2].s) / 3);

                    const centerCell = this.grid.getCell(centerQ, centerR, centerS);
                    if (centerCell && this.tokensRemaining[this.currentPlayer] >= 2) {
                        centerCell.territory = this.currentPlayer;
                        centerCell.territoryCount = 2;
                        this.tokensRemaining[this.currentPlayer] -= 2;
                    }
                }
            }

            hexDistance(cell1, cell2) {
                return (Math.abs(cell1.q - cell2.q) +
                        Math.abs(cell1.r - cell2.r) +
                        Math.abs(cell1.s - cell2.s)) / 2;
            }

            hasValidMoves() {
                const wizards = [];
                this.grid.cells.forEach(cell => {
                    if (cell.wizard === this.currentPlayer) {
                        wizards.push(cell);
                    }
                });

                // å„é­”æ³•ä½¿ã„ã«ã¤ã„ã¦ã€æœ‰åŠ¹ãªç§»å‹•å…ˆãŒã‚ã‚‹ã‹ç¢ºèª
                for (const wizard of wizards) {
                    const originalWizard = wizard.wizard;
                    wizard.wizard = null;

                    this.grid.cells.forEach(targetCell => {
                        if (targetCell.wizard) return;
                        if (targetCell.territory === (3 - this.currentPlayer)) return;

                        targetCell.wizard = this.currentPlayer;
                        const newTerritories = this.calculateNewTerritories();
                        if (newTerritories.length > 0) {
                            wizard.wizard = originalWizard;
                            targetCell.wizard = null;
                            return true;
                        }
                        targetCell.wizard = null;
                    });

                    wizard.wizard = originalWizard;
                }

                return false;
            }

            checkWin() {
                // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¨ã¦é…ç½®ã—ãŸ
                if (this.tokensRemaining[this.currentPlayer] === 0) {
                    this.gameOver = true;
                    this.updateMessage(`ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.currentPlayer}ã®å‹åˆ©ï¼ 20å€‹ã®é™£åœ°ã‚’é…ç½®ã—ã¾ã—ãŸ`, true);
                    return true;
                }
                return false;
            }

            endGame() {
                this.gameOver = true;
                const count1 = this.countTerritories(1);
                const count2 = this.countTerritories(2);

                let message;
                if (count1 > count2) {
                    message = `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã®å‹åˆ©ï¼ (${count1} vs ${count2})`;
                } else if (count2 > count1) {
                    message = `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã®å‹åˆ©ï¼ (${count2} vs ${count1})`;
                } else {
                    message = `å¼•ãåˆ†ã‘ï¼ (${count1} vs ${count2})`;
                }

                this.updateMessage(message, true);
            }

            countTerritories(player) {
                let count = 0;
                this.grid.cells.forEach(cell => {
                    if (cell.territory === player) {
                        count += cell.territoryCount;
                    }
                });
                return count;
            }

            render() {
                const svg = document.getElementById('board');

                // æ—¢å­˜ã®é­”æ³•ä½¿ã„ã¨ãƒãƒ¼ã‚«ãƒ¼ã‚’å‰Šé™¤
                svg.querySelectorAll('.wizard, .territory-marker').forEach(el => el.remove());

                this.grid.cells.forEach((cell, key) => {
                    // å…­è§’å½¢ã®è‰²ã‚’æ›´æ–°
                    let className = 'hex';

                    if (cell.territory) {
                        if (cell.territoryCount === 2) {
                            className += ` territory-double-${cell.territory}`;
                        } else {
                            className += ` territory-${cell.territory}`;
                        }
                    } else {
                        className += ' empty';
                    }

                    if (key === this.selectedWizard) {
                        className += ' selected';
                    } else if (!this.selectedWizard && cell.wizard === this.currentPlayer) {
                        className += ' selectable';
                    }

                    cell.element.setAttribute('class', className);

                    // é­”æ³•ä½¿ã„ã‚’æç”»
                    if (cell.wizard) {
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', cell.pixelX);
                        circle.setAttribute('cy', cell.pixelY);
                        circle.setAttribute('r', 15);
                        circle.setAttribute('class', `wizard wizard-${cell.wizard}`);
                        circle.setAttribute('stroke', '#333');
                        circle.setAttribute('stroke-width', 2);
                        circle.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.onHexClick(key);
                        });
                        svg.appendChild(circle);

                        // é­”æ³•ä½¿ã„ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆå¸½å­ã®ãƒãƒ¼ã‚¯ï¼‰
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', cell.pixelX);
                        text.setAttribute('y', cell.pixelY + 5);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('fill', 'white');
                        text.setAttribute('font-size', '16');
                        text.setAttribute('font-weight', 'bold');
                        text.setAttribute('pointer-events', 'none');
                        text.textContent = 'ğŸ§™';
                        svg.appendChild(text);
                    }

                    // å®ˆå‚™é™£åœ°ã®ãƒãƒ¼ã‚«ãƒ¼
                    if (cell.territory && cell.territoryCount === 2) {
                        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        marker.setAttribute('x', cell.pixelX);
                        marker.setAttribute('y', cell.pixelY + 5);
                        marker.setAttribute('text-anchor', 'middle');
                        marker.setAttribute('fill', 'white');
                        marker.setAttribute('font-size', '20');
                        marker.setAttribute('font-weight', 'bold');
                        marker.setAttribute('class', 'territory-marker');
                        marker.setAttribute('pointer-events', 'none');
                        marker.textContent = 'â­';
                        svg.appendChild(marker);
                    }
                });
            }

            updateInfo() {
                document.getElementById('p1-tokens').textContent = this.tokensRemaining[1];
                document.getElementById('p2-tokens').textContent = this.tokensRemaining[2];
                document.getElementById('p1-board').textContent = this.countTerritories(1);
                document.getElementById('p2-board').textContent = this.countTerritories(2);

                const p1Info = document.getElementById('player1-info');
                const p2Info = document.getElementById('player2-info');

                if (this.currentPlayer === 1) {
                    p1Info.classList.add('active');
                    p2Info.classList.remove('active');
                } else {
                    p1Info.classList.remove('active');
                    p2Info.classList.add('active');
                }

                if (!this.gameOver) {
                    this.updateMessage(`ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.currentPlayer}ã®ã‚¿ãƒ¼ãƒ³ - é­”æ³•ä½¿ã„ã‚’é¸æŠã—ã¦ãã ã•ã„`);
                }
            }

            updateMessage(text, isWinner = false) {
                const messageEl = document.getElementById('message');
                messageEl.textContent = text;
                messageEl.className = 'message' + (isWinner ? ' winner' : '');
            }
        }

        // ã‚²ãƒ¼ãƒ é–‹å§‹
        const game = new WizardTerritoryGame();
    </script>
</body>
</html>
